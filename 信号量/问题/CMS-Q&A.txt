1. 在pc.c中去掉所有与信号量有关的代码，再运行程序，执行效果有变化吗？为什么会这样？

答：效果完全不同，没有了信号量的控制，生产者可在缓冲区满了之后继续生产，导致没有被消费的数据被覆盖；消费者在缓冲区读完之后还继续读数据，读出的数据无效；没有了mutex 控制互斥访问缓存区，导致多个消费者和生产者并发访问缓存区，从而导致出现fread()错误。在我们实现的方式中，读取的位置不发生变化，导致一直读的都是0。

2. 实验的设计者在第一次编写生产者——消费者程序的时候，是这么做的：
Producer()
{
    P(Mutex);  //互斥信号量
    生产一个产品item;
    P(Empty);  //空闲缓存资源
    将item放到空闲缓存中;
    V(Full);  //产品资源
    V(Mutex);
}

Consumer()
{
    P(Mutex);  
    P(Full);  
    从缓存区取出一个赋值给item;
    V(Empty);
    消费产品item;
    V(Mutex);
} 
这样可行吗？如果可行，那么它和标准解法在执行效果上会有什么不同？如果不可行，那么它有什么问题使它不可行？

答：这样不可行。
会造成死锁，假如mutex=1,当前缓冲区为空，full=0，Consumer执行P(Mutex)后又执行P（full）,然后producer执行P(mutex)，那么full和mutex 的值将永远得不到变化，生产者和消费者陷入死锁。